<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Galaxy - Sinematic Edition</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: 'Arial', sans-serif;
        }
        /* Tombol Kembali */
        #back-button {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 20;
            background: rgba(0, 0, 0, 0.6);
            color: white;
            border: 1px solid rgba(255,215,0,0.5);
            padding: 10px 24px;
            border-radius: 40px;
            font-size: 1rem;
            font-weight: bold;
            text-decoration: none;
            letter-spacing: 1px;
            backdrop-filter: blur(8px);
            transition: 0.3s;
            box-shadow: 0 0 20px rgba(255,215,0,0.3);
            cursor: pointer;
        }
        #back-button:hover {
            background: rgba(255,215,0,0.2);
            border-color: #ffd700;
            box-shadow: 0 0 30px #ffd700;
            transform: scale(1.05);
        }
        #title {
            position: absolute;
            top: 5%;
            left: 0;
            width: 100%;
            text-align: center;
            color: #fff;
            font-size: 5rem;
            font-weight: 900;
            text-transform: uppercase;
            letter-spacing: 0.3em;
            text-shadow: 0 0 30px #ffaa00, 0 0 60px #ff5500, 0 0 90px #ff0000;
            z-index: 10;
            pointer-events: none;
            animation: pulseGlow 3s infinite alternate, fadeIn 2s ease-out;
            transform: translateZ(0);
            opacity: 0;
            animation-fill-mode: forwards;
        }
        @keyframes pulseGlow {
            0% { text-shadow: 0 0 30px #ffaa00, 0 0 60px #ff5500, 0 0 90px #ff0000; opacity: 0.9; }
            100% { text-shadow: 0 0 50px #ffdd44, 0 0 100px #ffaa00, 0 0 150px #ff5500; opacity: 1; }
        }
        @keyframes fadeIn {
            0% { opacity: 0; transform: translateY(-30px); }
            100% { opacity: 1; transform: translateY(0); }
        }
        #subtitle {
            position: absolute;
            top: 18%;
            left: 0;
            width: 100%;
            text-align: center;
            color: #ccf;
            font-size: 1.2rem;
            letter-spacing: 0.6em;
            text-shadow: 0 0 20px #aaf;
            z-index: 10;
            pointer-events: none;
            opacity: 0;
            animation: fadeInSub 2.5s ease-out forwards;
            animation-delay: 0.5s;
        }
        @keyframes fadeInSub {
            0% { opacity: 0; transform: translateY(20px); }
            100% { opacity: 1; transform: translateY(0); }
        }
        .info {
            position: absolute;
            bottom: 20px;
            right: 20px;
            color: rgba(255,255,255,0.5);
            font-size: 0.8rem;
            z-index: 10;
            background: rgba(0,0,0,0.5);
            padding: 5px 12px;
            border-radius: 20px;
            backdrop-filter: blur(5px);
            border: 1px solid rgba(255,215,0,0.3);
            opacity: 0;
            animation: fadeInInfo 3s ease-out forwards;
            animation-delay: 1s;
        }
        @keyframes fadeInInfo {
            0% { opacity: 0; }
            100% { opacity: 1; }
        }
    </style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>
<body>
    
    <button id="back-button" onclick="window.location.href='index.html'">← Kembali</button>
    <div id="subtitle">✦ DEEP SPACE ✦</div>

    <script>
        // === INIT THREE.JS ===
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x050510); // deep cosmic blue

        const camera = new THREE.PerspectiveCamera(50, window.innerWidth / window.innerHeight, 0.1, 8000);
        
        // Posisi awal untuk efek sinematik (lebih jauh)
        const targetCamPos = new THREE.Vector3(200, 80, 400); // posisi normal
        camera.position.set(200, 300, 1200); // mulai dari jauh atas

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        document.body.appendChild(renderer.domElement);

        // === HELPER: buat texture lingkaran untuk partikel nebula ===
        function createParticleTexture() {
            const canvas = document.createElement('canvas');
            canvas.width = 32;
            canvas.height = 32;
            const ctx = canvas.getContext('2d');
            ctx.clearRect(0, 0, 32, 32);
            
            const gradient = ctx.createRadialGradient(16, 16, 0, 16, 16, 16);
            gradient.addColorStop(0, 'rgba(255,255,255,1)');
            gradient.addColorStop(0.4, 'rgba(255,255,255,0.8)');
            gradient.addColorStop(0.6, 'rgba(200,200,255,0.3)');
            gradient.addColorStop(1, 'rgba(255,255,255,0)');
            
            ctx.fillStyle = gradient;
            ctx.fillRect(0, 0, 32, 32);
            return new THREE.CanvasTexture(canvas);
        }

        // === NEBULA / DUST CLOUD (partikel besar berwarna) ===
        const nebulaGeo = new THREE.BufferGeometry();
        const nebulaCount = 2000;
        const nebulaPositions = new Float32Array(nebulaCount * 3);
        const nebulaColors = new Float32Array(nebulaCount * 3);

        for (let i = 0; i < nebulaCount; i++) {
            const r = 800 + Math.random() * 700;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            
            const x = r * Math.sin(phi) * Math.cos(theta);
            const y = r * Math.sin(phi) * Math.sin(theta);
            const z = r * Math.cos(phi);
            
            nebulaPositions[i*3] = x;
            nebulaPositions[i*3+1] = y;
            nebulaPositions[i*3+2] = z;
            
            const color = new THREE.Color().setHSL(Math.random(), 0.5, 0.5 + 0.3 * Math.random());
            nebulaColors[i*3] = color.r;
            nebulaColors[i*3+1] = color.g;
            nebulaColors[i*3+2] = color.b;
        }

        nebulaGeo.setAttribute('position', new THREE.BufferAttribute(nebulaPositions, 3));
        nebulaGeo.setAttribute('color', new THREE.BufferAttribute(nebulaColors, 3));

        const nebulaMat = new THREE.PointsMaterial({
            size: 15,
            map: createParticleTexture(),
            vertexColors: true,
            transparent: true,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const nebulaPoints = new THREE.Points(nebulaGeo, nebulaMat);
        scene.add(nebulaPoints);

        // === PLANET UTAMA ===
        const PLANET_RADIUS = 70;

        const planet = new THREE.Mesh(
            new THREE.SphereGeometry(PLANET_RADIUS, 256, 256),
            new THREE.MeshPhongMaterial({
                color: 0xffaaff,
                emissive: 0x8822aa,
                emissiveIntensity: 1.5,
                shininess: 40
            })
        );
        scene.add(planet);

        const glow = new THREE.Mesh(
            new THREE.SphereGeometry(PLANET_RADIUS + 8, 128, 128),
            new THREE.MeshBasicMaterial({
                color: 0xff88ff,
                transparent: true,
                opacity: 0.25,
                blending: THREE.AdditiveBlending
            })
        );
        scene.add(glow);

        // === BULAN / PLANET KECIL MENGELILINGI PUSAT ===
        const moons = [];
        const moonCount = 3;
        const moonData = [
            { color: 0x88ccff, radius: 12, orbitRadius: 140, speed: 0.004, emissive: 0x224466 },
            { color: 0xffaa88, radius: 10, orbitRadius: 210, speed: 0.0025, emissive: 0x663322 },
            { color: 0x99ff99, radius: 8, orbitRadius: 280, speed: 0.0018, emissive: 0x226622 }
        ];

        moonData.forEach((data, index) => {
            const geometry = new THREE.SphereGeometry(data.radius, 64, 64);
            const material = new THREE.MeshPhongMaterial({
                color: data.color,
                emissive: data.emissive,
                emissiveIntensity: 0.8,
                shininess: 30
            });
            const moon = new THREE.Mesh(geometry, material);
            
            const angle = (index / moonCount) * Math.PI * 2;
            moon.position.x = Math.cos(angle) * data.orbitRadius;
            moon.position.z = Math.sin(angle) * data.orbitRadius;
            moon.position.y = (Math.random() - 0.5) * 30;
            
            scene.add(moon);
            
            const moonGlow = new THREE.Mesh(
                new THREE.SphereGeometry(data.radius + 2, 32, 32),
                new THREE.MeshBasicMaterial({
                    color: data.color,
                    transparent: true,
                    opacity: 0.15,
                    blending: THREE.AdditiveBlending
                })
            );
            moon.add(moonGlow);
            
            moons.push({
                mesh: moon,
                orbitRadius: data.orbitRadius,
                speed: data.speed,
                angle: angle,
                yOffset: moon.position.y,
                ySpeed: 0.002 + Math.random() * 0.002
            });
        });

        // === ASTEROID BELT ===
        const asteroidGeo = new THREE.BufferGeometry();
        const astCount = 4000;
        const astPositions = new Float32Array(astCount * 3);
        const astColors = new Float32Array(astCount * 3);

        for (let i = 0; i < astCount; i++) {
            const r = 150 + Math.random() * 120;
            const angle = Math.random() * Math.PI * 2;
            const y = (Math.random() - 0.5) * 50;
            
            const x = Math.cos(angle) * r;
            const z = Math.sin(angle) * r;
            
            astPositions[i*3] = x;
            astPositions[i*3+1] = y;
            astPositions[i*3+2] = z;
            
            const gray = 0.5 + Math.random() * 0.5;
            astColors[i*3] = gray;
            astColors[i*3+1] = gray * 0.8;
            astColors[i*3+2] = gray * 0.6;
        }

        asteroidGeo.setAttribute('position', new THREE.BufferAttribute(astPositions, 3));
        asteroidGeo.setAttribute('color', new THREE.BufferAttribute(astColors, 3));

        const astMat = new THREE.PointsMaterial({
            size: 0.8,
            vertexColors: true,
            map: createParticleTexture(),
            blending: THREE.NormalBlending,
            transparent: true,
            opacity: 0.8
        });

        const asteroidBelt = new THREE.Points(asteroidGeo, astMat);
        scene.add(asteroidBelt);

        // ============================================================
        // FOTO ORBIT – 300 GAMBAR DARI 20 FILE LOKAL (di folder IMG/)
        // ============================================================
        const textureLoader = new THREE.TextureLoader();
        const photoGroup = new THREE.Group();
        scene.add(photoGroup);

        const photos = [];
        const TOTAL_PHOTOS = 100; // sesuai permintaan

        const PHOTOS_PER_LAYER = 25;
        const LAYER_GAP = 35;

        let currentLayer = 0;
        let photoIndex = 0;

        while (photoIndex < TOTAL_PHOTOS) {
            const radius = PLANET_RADIUS + 100 + (currentLayer * LAYER_GAP);
            const itemsInLayer = Math.min(
                PHOTOS_PER_LAYER + currentLayer * 6,
                TOTAL_PHOTOS - photoIndex
            );

            for (let i = 0; i < itemsInLayer; i++) {
                const angle = (i / itemsInLayer) * Math.PI * 2;
                // Tentukan nomor gambar 1..20 berdasarkan urutan
                const imgNumber = (photoIndex % 10) + 1;
                // Path gambar di folder IMG (relatif terhadap lokasi HTML)
                const imagePath = `../IMG/p${imgNumber}.jpeg`;

                textureLoader.load(
                    imagePath,
                    (texture) => {
                        const mesh = new THREE.Mesh(
                            new THREE.PlaneGeometry(6, 8),
                            new THREE.MeshBasicMaterial({
                                map: texture,
                                side: THREE.DoubleSide,
                                emissive: 0x333333
                            })
                        );

                        const randomOffset = Math.random() * 15;
                        mesh.position.x = Math.cos(angle) * (radius + randomOffset);
                        mesh.position.z = Math.sin(angle) * (radius + randomOffset);
                        mesh.position.y = (Math.random() - 0.5) * 50;

                        mesh.rotation.z = (Math.random() - 0.5) * 0.5;
                        mesh.lookAt(0, 0, 0);

                        photoGroup.add(mesh);

                        photos.push({
                            mesh: mesh,
                            speed: 0.3 + Math.random() * 0.5,
                            floatOffset: Math.random() * Math.PI * 2
                        });
                    },
                    undefined,
                    (err) => {
                        console.error(`Gagal memuat gambar: ${imagePath}`, err);
                    }
                );
                photoIndex++;
            }
            currentLayer++;
        }

        // === RING TEXT ===
        function createOrbitRing(text, radius, tilt, color) {
            const canvas = document.createElement("canvas");
            canvas.width = 16384;
            canvas.height = 1024;

            const ctx = canvas.getContext("2d");
            ctx.font = "bold 280px 'Arial', 'sans-serif'";
            ctx.fillStyle = color;
            ctx.textAlign = "left";
            ctx.textBaseline = "middle";
            ctx.shadowColor = "rgba(255,255,255,0.8)";
            ctx.shadowBlur = 20;

            const repeated = `${text} ✦ ${text} ✦ ${text} ✦ `;
            ctx.fillText(repeated.repeat(8), 0, canvas.height / 2);

            const texture = new THREE.CanvasTexture(canvas);
            texture.wrapS = THREE.RepeatWrapping;
            texture.repeat.x = 5;

            const geometry = new THREE.CylinderGeometry(radius, radius, 15, 1024, 1, true);
            const material = new THREE.MeshBasicMaterial({
                map: texture,
                transparent: true,
                opacity: 0.9,
                side: THREE.DoubleSide,
                blending: THREE.AdditiveBlending,
                depthWrite: false
            });

            const mesh = new THREE.Mesh(geometry, material);
            const tiltGroup = new THREE.Group();
            tiltGroup.rotation.x = tilt;
            tiltGroup.add(mesh);

            const orbitGroup = new THREE.Group();
            orbitGroup.add(tiltGroup);
            scene.add(orbitGroup);

            return { orbitGroup, texture };
        }

        const ring1 = createOrbitRing("***************", PLANET_RADIUS + 15, 0.45, "#ffaa88");
        const ring2 = createOrbitRing("***************", PLANET_RADIUS + 55, 0.55, "#aaccff");
        const ring3 = createOrbitRing("***************", PLANET_RADIUS + 110, 0.35, "#ffccaa");
        const ring4 = createOrbitRing("***************", PLANET_RADIUS + 180, 0.65, "#ccffaa");

        // === BINTANG LATAR ===
        const starGeo = new THREE.BufferGeometry();
        const starCount = 12000;
        const starPositions = new Float32Array(starCount * 3);
        const starSizes = new Float32Array(starCount);

        for (let i = 0; i < starCount; i++) {
            starPositions[i*3] = (Math.random() - 0.5) * 5000;
            starPositions[i*3+1] = (Math.random() - 0.5) * 5000;
            starPositions[i*3+2] = (Math.random() - 0.5) * 5000;
            starSizes[i] = 0.5 + Math.random() * 2;
        }

        starGeo.setAttribute("position", new THREE.BufferAttribute(starPositions, 3));
        starGeo.setAttribute("size", new THREE.BufferAttribute(starSizes, 1));

        const starMat = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 1.2,
            map: createParticleTexture(),
            blending: THREE.AdditiveBlending,
            sizeAttenuation: true
        });

        const stars = new THREE.Points(starGeo, starMat);
        scene.add(stars);

        // === LIGHTING ===
        const ambientLight = new THREE.AmbientLight(0x404060);
        scene.add(ambientLight);

        const pointLight1 = new THREE.PointLight(0xff88aa, 2, 800);
        pointLight1.position.set(200, 200, 200);
        scene.add(pointLight1);

        const pointLight2 = new THREE.PointLight(0x88aaff, 1.5, 800);
        pointLight2.position.set(-200, -100, 200);
        scene.add(pointLight2);

        const planetLight = new THREE.PointLight(0xff66aa, 3, 500);
        planetLight.position.set(0, 0, 0);
        scene.add(planetLight);

        // === ORBIT CONTROLS (akan diaktifkan setelah sinematik) ===
        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.05;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 0.8;
        controls.enableZoom = true;
        controls.maxDistance = 1200;
        controls.minDistance = 200;
        controls.enabled = false; // matikan dulu selama sinematik

        // === SINEMATIK AWAL ===
        let cinematicActive = true;
        const cinematicDuration = 4000; // 4 detik
        const startTime = performance.now();
        const startCamPos = camera.position.clone();

        // === ANIMATION LOOP ===
        let clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            const elapsedTime = performance.now() * 0.001;
            const now = performance.now();

            // Sinematik: interpolasi posisi kamera
            if (cinematicActive) {
                const progress = Math.min((now - startTime) / cinematicDuration, 1);
                // easing smoothstep
                const eased = progress * progress * (3 - 2 * progress);
                camera.position.lerpVectors(startCamPos, targetCamPos, eased);
                
                // Kamera menghadap ke pusat (0,0,0)
                camera.lookAt(0, 0, 0);

                if (progress >= 1) {
                    cinematicActive = false;
                    controls.enabled = true; // aktifkan controls setelah sinematik
                }
            }

            // Rotasi planet
            planet.rotation.y -= 0.0015;
            glow.rotation.y -= 0.001;

            // Rotasi ring teks
            ring1.orbitGroup.rotation.y += 0.004;
            ring2.orbitGroup.rotation.y -= 0.0035;
            ring3.orbitGroup.rotation.y += 0.003;
            ring4.orbitGroup.rotation.y -= 0.0025;

            // Geser tekstur ring
            ring1.texture.offset.x -= 0.003;
            ring2.texture.offset.x += 0.0025;
            ring3.texture.offset.x -= 0.002;
            ring4.texture.offset.x += 0.0015;

            // Rotasi foto orbit
            photoGroup.rotation.y += 0.0012;

            // Animasi floating foto
            photos.forEach(p => {
                p.mesh.position.y += Math.sin(elapsedTime * p.speed + p.floatOffset) * 0.03;
            });

            // Gerakkan bulan
            moons.forEach(moon => {
                moon.angle += moon.speed * delta * 30;
                const x = Math.cos(moon.angle) * moon.orbitRadius;
                const z = Math.sin(moon.angle) * moon.orbitRadius;
                moon.mesh.position.x = x;
                moon.mesh.position.z = z;
                moon.mesh.position.y = moon.yOffset + Math.sin(elapsedTime * moon.ySpeed * 5) * 8;
                moon.mesh.rotation.y += 0.01;
            });

            // Rotasi asteroid belt
            asteroidBelt.rotation.y += 0.0005;
            asteroidBelt.rotation.x += 0.0001;

            // Rotasi bintang
            stars.rotation.y -= 0.0001;
            stars.rotation.x += 0.00005;

            // Rotasi nebula
            nebulaPoints.rotation.y += 0.0002;

            controls.update(); // hanya berefek jika controls.enabled = true
            renderer.render(scene, camera);
        }

        animate();

        window.addEventListener("resize", () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

        // Inisialisasi sudut bulan
        moons.forEach((moon, idx) => {
            moon.angle = (idx / moons.length) * Math.PI * 2;
        });
    </script>
</body>
</html>